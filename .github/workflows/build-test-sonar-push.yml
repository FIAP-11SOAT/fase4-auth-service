name: Build/Test/Sonar/Push

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]

env:
  REPOSITORY_NAME: ${{ github.event.repository.name }}
  REPORTS_PATH: reports

jobs:

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build imagem de teste
      - name: Build Docker test image
        run: docker build --no-cache -t $REPOSITORY_NAME-tests:latest --target tests  .

      - name: Save test image as tar
        run: docker save $REPOSITORY_NAME-tests:latest -o $REPOSITORY_NAME-tests.tar

      - name: Upload test image tar
        uses: actions/upload-artifact@v4
        with:
          name: docker-test-image
          path: ${{ env.REPOSITORY_NAME }}-tests.tar

      # Build imagem de produção
      - name: Build Docker production image
        run: docker build --no-cache -t $REPOSITORY_NAME-app:latest --target production .

      - name: Save production image as tar
        run: docker save $REPOSITORY_NAME-app:latest -o $REPOSITORY_NAME-prod.tar

      - name: Upload production image tar
        uses: actions/upload-artifact@v4
        with:
          name: docker-prod-image
          path: ${{ env.REPOSITORY_NAME }}-prod.tar

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: build
    services:
      dynamodb:
        image: amazon/dynamodb-local
        ports:
          - 8000:8000
    steps:
      - name: Download test image tar
        uses: actions/download-artifact@v5
        with:
          name: docker-test-image

      - name: Load test image
        run: docker load -i $REPOSITORY_NAME-tests.tar

      - name: Get Docker Network IP
        run: echo "DOCKER_NETWORK_NAME=$(docker network ls --format '{{.Name}}' | grep github_network_)" >> $GITHUB_ENV

      - name: Prepare reports directory
        run: mkdir -p ${{ github.workspace }}/reports

      - name: Execute tests and generate reports
        run: |
          docker run --rm \
            --network ${{ env.DOCKER_NETWORK_NAME }} \
            -v ${{ github.workspace }}/reports:/home/app/reports \
            $REPOSITORY_NAME-tests:latest

      - name: Move reports to workspace
        run: |
          mv ${{ github.workspace }}/reports/report.xml ${{ github.workspace }}/report.xml
          mv ${{ github.workspace }}/reports/coverage.xml ${{ github.workspace }}/coverage.xml

      - name: Fix coverage.xml paths using GitHub workspace variable
        run: sed -i "s|/home/app/source|${{ github.workspace }}/source|g" coverage.xml

      - name: Upload test reports for Sonar
        uses: actions/upload-artifact@v4
        with:
          name: test-coverage-file
          path: |
            report.xml
            coverage.xml

  sonar:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis

      - name: Download test reports
        uses: actions/download-artifact@v5
        with:
          name: test-coverage-file

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: sonar
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      - name: Terraform Init
        working-directory: ./deploy/terraform
        run: terraform init -input=false

      - name: Terraform Apply
        working-directory: ./deploy/terraform
        run: terraform apply -auto-approve

  push:
    name: Push Production Image & Deploy to ECS
    runs-on: ubuntu-latest
    needs: [sonar, terraform]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download production image tar
        uses: actions/download-artifact@v5
        with:
          name: docker-prod-image

      - name: Load production image
        run: docker load -i ${{ env.REPOSITORY_NAME }}-prod.tar

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Get AWS Account ID
        run: |
          echo "AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_ENV

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set ECR variables
        run: |
          echo "ECR_REGISTRY=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com" >> $GITHUB_ENV
          echo "ECR_REPOSITORY=${{ env.REPOSITORY_NAME }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV

      - name: Tag and push images to ECR
        run: |
          docker tag ${{ env.REPOSITORY_NAME }}-app:latest $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker tag ${{ env.REPOSITORY_NAME }}-app:latest $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Determine ECS cluster and service
        run: |
          if [ -n "${{ secrets.ECS_CLUSTER }}" ]; then
            echo "ECS_CLUSTER=${{ secrets.ECS_CLUSTER }}" >> $GITHUB_ENV
          else
            echo "ECS_CLUSTER=${{ env.REPOSITORY_NAME }}-cluster" >> $GITHUB_ENV
          fi
          if [ -n "${{ secrets.ECS_SERVICE }}" ]; then
            echo "ECS_SERVICE=${{ secrets.ECS_SERVICE }}" >> $GITHUB_ENV
          else
            echo "ECS_SERVICE=${{ env.REPOSITORY_NAME }}-service" >> $GITHUB_ENV
          fi

      - name: Update ECS service (force new deployment)
        env:
          AWS_REGION: us-east-1
        run: |
          aws ecs update-service --cluster "$ECS_CLUSTER" --service "$ECS_SERVICE" --force-new-deployment --region $AWS_REGION
